<!doctype html>
<html class="loading">
	<head>
		<meta charset="utf8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>3d</title>
		<link rel="preconnect" href="https://fonts.gstatic.com">
		<link href="https://fonts.googleapis.com/css2?family=Alfa+Slab+One&family=Comfortaa:wght@300&family=Eczar:wght@800&family=Gloria+Hallelujah&family=Montserrat:wght@300&family=Raleway:wght@900&family=Ultra&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="splitting.css">
		<style>
			* {
				box-sizing: border-box;
			}

			html {
				background: white; /* linear-gradient(to bottom, #4375bb, #bfd7e8) no-repeat; */
				background-attachment: fixed;
				font-size: 100%;
				scroll-snap-type: y mandatory;
				scroll-behavior: smooth;
			}

			html.loading::before {
				content: "Loading...";
				position: fixed;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
			}

			html.loading * {
				visibility: hidden;
			}

			body {
				margin: 0;
				font: 1rem/2 Montserrat, sans-serif;
			}

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				font: 8rem/0.9 Raleway, serif;
				letter-spacing: -0.025em;
				margin: 0 0 1rem;
			}

			section {
				display: flex;
				align-items: flex-start;
				justify-content: center;
				flex-direction: column;
				padding: 3rem 5vw;
				min-height: 100vh;
				scroll-snap-align: start;
				scroll-snap-stop: always;
			}

			.slide {
				width: calc(100% + 2rem);
				white-space: nowrap;
				overflow-x: auto;
				scroll-snap-type: x mandatory;
				scroll-behavior: smooth;
				scroll-padding: 0 2rem;
				padding: 2rem 0 2rem 2rem;
				margin: -2rem 0 -2rem -2rem;
			}

			.slide > * {
				display: inline-block;
				width: 18rem;
				margin-right: 4rem;
				scroll-snap-align: start;
				scroll-snap-stop: always;
			}

			.card {
				background: white;
				min-height: 24rem;
				box-shadow: 0 0.2rem 1rem rgba(0, 0, 0, 0.2);
			}

			#bg {
				position: fixed;
				left: 0;
				top: 0;
				right: 0;
				bottom: 0;
				z-index: 1;
				margin: 0;
				pointer-events: none;
			}

			#bg canvas {
				position: absolute;
				left: 0;
				top: 0;
				outline: 0;

				width: 100%;
				height: 100%;

				object-fit: cover;
				object-position: center center;
			}

			#about {
				padding-right: 55%;
			}

			#projects {
				padding-left: 30%;
				padding-right: 0;
			}

			#contact {
				padding-left: 25%;
			}

			#end {
				padding-left: 50%;
			}

			h1.splitting,
			h2.splitting {
				perspective: 300px;
			}

			h1.splitting .char,
			h2.splitting .char {
				transform: rotateX(90deg);
				transform-origin: 50% bottom;
				opacity: 0;
				transition: transform 1s ease, opacity 0.25s ease;
				transition-delay: calc(0.05s * var(--char-index) + 0.5s);
			}

			.in-view h1.splitting .char,
			.in-view h2.splitting .char {
				transform: rotateX(0);
				opacity: 1;
			}
		</style>
	</head>
	<body>
		<figure id="bg"></figure>
		<main>

			<section id="about" data-camera-pos='{"x": -2, "y": 0.075, "z": 0.25, "rx": 0, "ry": 0, "rz": 0}'>

				<h1>Hi! I'm Andreas</h1>

				<p>I'm a self taught computer nerd from the icy cold northern parts of Sweden.</p>

				<ul>
					<li><a href="https://github.com/powerbuoy/">GitHub</a></li>
					<li><a href="http://stackoverflow.com/users/1074594/powerbuoy">StackOverflow</a></li>
				</ul>

			</section>

			<section id="projects" data-camera-pos='{"x": 0.0, "y": 1, "z": 2, "rx": 0, "ry": 0, "rz": 0}'>

				<h2>Projects</h2>

				<div class="slide">
					<article class="card"><a href="#">Moar</a></article>
					<article class="card"><a href="#">Moar</a></article>
					<article class="card"><a href="#">Moar</a></article>
					<article class="card"><a href="#">Moar</a></article>
					<article class="card"><a href="#">Moar</a></article>
					<article class="card"><a href="#">Moar</a></article>
				</div>

			</section>

			<section id="contact" data-camera-pos='{"x": 5, "y": 2, "z": 10, "rx": 0, "ry": 0, "rz": 0}'>

				<h2>Contact</h2>

				<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>

			</section>

			<section id="end" data-camera-pos='{"x": 30, "y": 3, "z": 60, "rx": 0, "ry": 0, "rz": 0}'>

				<h2>This is the End</h2>

			</section>

		</main>

		<script src="ThreeJS.js"></script>
		<script src="GLTFLoader.js"></script>
		<script src="tween.umd.js"></script>
		<script src="splitting.js"></script>
		<script>
			// Splitting
			Splitting({
				target: 'h1, h2',
				by: 'chars'
			});

			Splitting({
				target: 'p',
				by: 'lines'
			});

			// 3D Background
			class Bg3d {
				constructor (el, conf) {
					this.clock = new THREE.Clock();

					this.el = el;
					this.config = Object.assign({
						fov: 45,
						scene: 'new.glb',
						easing: TWEEN.Easing.Quadratic.InOut,
						cameraTransitionDuration: 750,
						mouseTransitionDuration: 1500
					}, conf);

					this.init();
					this.initialCameraPos();
					this.scrollCameraPos();
					this.mousemoveCameraPos();
					this.loadScene();
					this.lights();
				}

				// Create scene, renderer etc
				init () {
					this.scene = new THREE.Scene();
					this.renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
					this.camera = new THREE.PerspectiveCamera(this.config.fov, this.el.clientWidth / this.el.clientHeight, 0.01, 5000);

					this.renderer.setSize(this.el.clientWidth, this.el.clientHeight);
					this.el.appendChild(this.renderer.domElement);

					this.renderer.shadowMap.enabled = true;
					this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
					this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

					window.addEventListener('resize', e => {
						this.camera.aspect = this.el.clientWidth / this.el.clientHeight;
						this.camera.updateProjectionMatrix();
						this.renderer.setSize(this.el.clientWidth, this.el.clientHeight);
					});
				}

				// Set initial camera position
				initialCameraPos () {
					const initialPos = JSON.parse(document.querySelector('[data-camera-pos]').dataset.cameraPos);

					this.camera.position.set(initialPos.x, initialPos.y, initialPos.z);
					this.camera.rotation.set(initialPos.rx, initialPos.ry, initialPos.rz);
				}

				// Change camera position when user scrolls a camera-pos element into view
				scrollCameraPos () {
					// Change camera position when entering camera-pos elements
					document.querySelectorAll('[data-camera-pos]').forEach(el => {
						new IntersectionObserver(entries => entries.forEach(entry => {
							if (entry.isIntersecting) {
								entry.target.classList.add('in-view');

								// TODO: Tailor made transitions for every scene... (move xy first then z etc) (can't store positions in dataset, will require custom code for every transition and also depending on from which scene to whcih scene...)
								const newPos = JSON.parse(entry.target.dataset.cameraPos);

								new TWEEN.Tween(this.camera.position).to({x: newPos.x, y: newPos.y, z: newPos.z}, this.config.cameraTransitionDuration).easing(this.config.easing).start();
								new TWEEN.Tween(this.camera.rotation).to({x: newPos.rx, y: newPos.ry, z: newPos.rz}, this.config.cameraTransitionDuration).easing(this.config.easing).start();
								new TWEEN.Tween(this.scene.position).to({x: 0, y: 0}, this.config.cameraTransitionDuration).easing(this.config.easing).start();
							}
							else {
								entry.target.classList.remove('in-view');
							}
						}), {threshold: 0.25}).observe(el);
					});
				}

				// Move camera (scene actually) on mousemove
				mousemoveCameraPos () {
					document.body.addEventListener('mousemove', e => {
						const mousemoveMax = this.camera.position.z / 10;
						const halfW = window.innerWidth / 2;
						const halfH = window.innerHeight / 2;
						const x = ((e.clientX - halfW) / halfW) * mousemoveMax;
						const y = ((e.clientY - halfH) / halfH) * mousemoveMax;

						// TODO: Performance impact of adding tween every mousemove?!
						this.scene.position.x = -x;
						this.scene.position.y = y;

						console.log([x, y]);

						// new TWEEN.Tween(this.scene.position).to({x: -x, y: y}, this.config.mouseTransitionDuration).easing(this.config.easing).start();
					});
				}

				// Add lights (TODO: How come Blender lights in the GLB don't work!?)
				lights () {
					this.ambLight = new THREE.AmbientLight(0xffffff, 1);
					this.scene.add(this.ambLight);
				}

				// Load scene
				loadScene () {
					this.loader = new THREE.GLTFLoader();

					this.loader.load(this.config.scene, glb => {
						// Cast shadows on all meshes
						glb.scene.traverse(node => {
							if (node.isMesh) {
								node.castShadow = true;
								node.receiveShadow = true;

								// And do this...? Anisotropic Filtering I guess?
								if (node.material.map) {
									node.material.map.anisotropy = 16;
								}
							}
						});

						this.scene.add(glb.scene);
						document.documentElement.classList.remove('loading');
					});
				}

				// Update animations
				update () {
					// TODO: Animate elements in the scene
					const delta = this.clock.getDelta();
				}

				// Render
				render () {
					this.update();
					TWEEN.update();
					this.renderer.render(this.scene, this.camera);
				}
			}

			// Render
			window.bg = new Bg3d(document.getElementById('bg'));

			function render () {
				window.bg.render();
				requestAnimationFrame(render);
			}

			render();
		</script>
	</body>
</html>
