<!doctype html>
<html class="loading">
	<head>
		<meta charset="utf8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>3d</title>
		<style>
			* {
				box-sizing: border-box;
			}

			html {
				background: linear-gradient(to bottom, #4375bb, #bfd7e8) no-repeat;
				background-attachment: fixed;
				font-size: 100%;
				scroll-snap-type: y mandatory;
				scroll-behavior: smooth;
			}

			html.loading::before {
				content: "Loading...";
				position: fixed;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
			}

			html.loading * {
				visibility: hidden;
			}

			body {
				margin: 0;
				font: 1rem/2 Helvetica, sans-serif;
			}

			figure {
				position: fixed;
				left: 0;
				top: 0;
				right: 0;
				bottom: 0;
				z-index: 1;
				margin: 0;
				pointer-events: none;
			}

			figure canvas {
				position: absolute;
				left: 0;
				top: 0;
				outline: 0;

				width: 100%;
				height: 100%;

				object-fit: cover;
				object-position: center center;
			}

			h1,
			h2,
			h3,
			h4,
			h5,
			h6 {
				font-size: 6rem;
				line-height: 1.05;
				margin: 0 0 1rem;
			}

			section {
				display: flex;
				align-items: flex-start;
				justify-content: center;
				flex-direction: column;
				padding: 3rem 5vw;
				min-height: 100vh;
				scroll-snap-align: start;
				scroll-snap-stop: always;
			}

			section > * {
				transform: translateY(2rem);
				opacity: 0;
				transition: transform 1s ease, opacity 1s ease;
			}

			section > :nth-child(1) {
				transition-delay: 1s;
			}

			section > :nth-child(2) {
				transition-delay: 1.25s;
			}

			section.in-view > * {
				transform: translateY(0);
				opacity: 1;
			}

			#about {
				padding-right: 60%;
			}

			#projects {
				padding-left: 30%;
				padding-right: 0;
			}

			#contact {

			}

			.slide {
				max-width: 100%;
				white-space: nowrap;
				overflow-x: auto;
				scroll-snap-type: x mandatory;
				scroll-behavior: smooth;
			}

			.card {
				display: inline-block;
				background: white;
				min-height: 24rem;
				margin-right: 2rem;
				width: 18rem;
				scroll-snap-align: start;
				scroll-snap-stop: always;
			}
		</style>
	</head>
	<body>
		<figure id="bg"></figure>
		<main>
			<section id="about" data-camera-pos='{"x": -2, "y": 0.075, "z": 0.25, "rx": 0, "ry": 0, "rz": 0}'>
				<h1>Hi! I'm Andreas</h1>
				<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>
			</section>
			<section id="projects" data-camera-pos='{"x": 0.0, "y": 1, "z": 2, "rx": 0, "ry": 0, "rz": 0}'>
				<h2>Projects</h2>
				<div class="slide">
					<article class="card"></article>
					<article class="card"></article>
					<article class="card"></article>
					<article class="card"></article>
					<article class="card"></article>
					<article class="card"></article>
				</div>
			</section>
			<section id="contact" data-camera-pos='{"x": 0, "y": 2.75, "z": 12.5, "rx": 0, "ry": 0, "rz": 0}'>
				<h2>Contact</h2>
				...
			</section>
		</main>
		<script src="ThreeJS.js"></script>
		<script src="GLTFLoader.js"></script>
		<script src="tween.umd.js"></script>
		<script>
			class Bg3d {
				constructor (el, conf) {
					this.clock = new THREE.Clock();

					this.el = el;
					this.config = Object.assign({
						fov: 50,
						scene: 'new.glb',
						easing: TWEEN.Easing.Quadratic.InOut,
						cameraTransitionDuration: 1000,
						mouseTransitionDuration: 500
					}, conf);

					this.init();
					this.cameraPos();
					this.scrollCameraPos();
					this.mousemoveCameraPos();
					this.loadScene();
					this.lights();
				}

				init () {
					this.scene = new THREE.Scene();
					this.renderer = new THREE.WebGLRenderer({antialias: true, alpha: true});
					this.camera = new THREE.PerspectiveCamera(this.config.fov, this.el.clientWidth / this.el.clientHeight, 0.01, 5000);

					this.renderer.setSize(this.el.clientWidth, this.el.clientHeight);
					this.el.appendChild(this.renderer.domElement);

					this.renderer.shadowMap.enabled = true;
					this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
					this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

					window.addEventListener('resize', e => {
						this.camera.aspect = this.el.clientWidth / this.el.clientHeight;
						this.camera.updateProjectionMatrix();
						this.renderer.setSize(this.el.clientWidth, this.el.clientHeight);
					});
				}

				cameraPos () {
					// Set initial position
					const initialPos = JSON.parse(document.querySelector('[data-camera-pos]').dataset.cameraPos);

					this.camera.position.set(initialPos.x, initialPos.y, initialPos.z);
					this.camera.rotation.set(initialPos.rx, initialPos.ry, initialPos.rz);
				}

				scrollCameraPos () {
					// Change camera position when entering camera-pos elements
					document.querySelectorAll('[data-camera-pos]').forEach(el => {
						new IntersectionObserver(entries => entries.forEach(entry => {
							if (entry.isIntersecting) {
								entry.target.classList.add('in-view');

								const newPos = JSON.parse(entry.target.dataset.cameraPos);

								new TWEEN.Tween(this.camera.position).to({x: newPos.x, y: newPos.y, z: newPos.z}, this.config.cameraTransitionDuration).easing(this.config.easing).start();
								new TWEEN.Tween(this.camera.rotation).to({x: newPos.rx, y: newPos.ry, z: newPos.rz}, this.config.cameraTransitionDuration).easing(this.config.easing).start();
								new TWEEN.Tween(this.scene.position).to({x: 0, y: 0}, this.config.cameraTransitionDuration).easing(this.config.easing).start();
							}
							else {
								entry.target.classList.remove('in-view');
							}
						}), {threshold: 0.25}).observe(el);
					});
				}

				mousemoveCameraPos () {
					// Move scene on mouse move
					document.body.addEventListener('mousemove', e => {
						const mousemoveMax = this.camera.position.z / 50;
						const halfW = window.innerWidth / 2;
						const halfH = window.innerHeight / 2;
						const x = ((e.clientX - halfW) / halfW) * mousemoveMax;
						const y = ((e.clientY - halfH) / halfH) * mousemoveMax;

						// TODO: Performance impact of adding tween every mousemove?!
						new TWEEN.Tween(this.scene.position).to({x: -x, y: y}, this.config.mouseTransitionDuration).easing(this.config.easing).start();
					});
				}

				lights () {
					this.ambLight = new THREE.AmbientLight(0xffffff, 1);
					this.scene.add(this.ambLight);
				}

				loadScene () {
					this.loader = new THREE.GLTFLoader();

					this.loader.load(this.config.scene, glb => {
						// Cast shadows on all meshes
						glb.scene.traverse(node => {
							if (node.isMesh) {
								node.castShadow = true;
								node.receiveShadow = true;

								// And do this...? Anisotropic Filtering I guess?
								if (node.material.map) {
									node.material.map.anisotropy = 16;
								}
							}
						});

						this.scene.add(glb.scene);
						document.documentElement.classList.remove('loading');
					});
				}

				update () {
					// TODO: Animate elements in the scene
				}

				render () {
					this.update();
					TWEEN.update();
					this.renderer.render(this.scene, this.camera);
				}
			}

			// Render
			window.bg = new Bg3d(document.getElementById('bg'));

			function render () {
				window.bg.render();
				requestAnimationFrame(render);
			}

			render();
		</script>
	</body>
</html>
